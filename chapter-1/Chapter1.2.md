# 1.2 Procedures and the Processes They Generate

https://www.youtube.com/watch?v=V_7mmwpgJHU&list=PLE18841CABEA24090&index=2&t=9s

> The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer.

Now we are chess players, who know the rules, but are ignorant to the common patterns of the usage in the domain.

To become experts we must learn to visualize the process generated by various types of procedures.

A procedure is a pattern for the _local evolution_ of a computation process. It specifies how each stage of the progress is built upon the previous stage.

We would like to make statements about the overall, _or global_ behavior of a process, whose local evolution has been specified by a procedure. - What happens and you consider all the steps of a procedure collectively.

### Linear Recursive process (Recursion)

```racket
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
(720)

time = O(n);
space = O(n);
```

This processes generates a chain of _differed operations._ Operations that the interpreter must keep track. When the interpreter starts to perform these operations, the _contraction_ starts to occur.

In this type of process, the **amount of information** the interpreter must keep track is proportional to `n`. It grows linearly with it.

Here there are “hidden information” on the interpreter, the calculations its deferring to do later. The longer the chain, more information it needs to store.

Generate a branching three-like pattern of execution, here the function call itself multiple times and it grows with

TIME ⬇️

➡️ SPACE

### Linear Iterative Process (Iteration)

```racket
(define (factorial n) (iter 1 1 n))

(define (iter product counter max-count)
  ; I was putting a = sign why was it not working ?
  ; Becase it will stop before the last needed multiplication. S (factorial 6) would actually be counted only until 5
  (if (= counter max-count)
      product
      (iter (* product counter) (+ counter 1) max-count)) ; Here we just make the calculation calling the inter with the new number
  )

(factorial 6)
; (iter 1 1 6)
; (iter 1 2 6)
; (iter 2 3 6)
; (iter 6 4 6)
; (iter 24 5 6)
; (iter 120 6 6)
; 720

time = O(n);
space = O(1);
```

This processes, we only need to keep track of the variables that will call the `iter` procedure.

One whose state can be summarized by a fixed number of _state variables,_ together with a fixed rule that describe how they should be updated

In this process, the _number of procedures_ grows linearly with n*.*

So when we compare both, one the amount of information grows with n and the other the amount of procedures.

**Recursive Procedure ≠ Recursive Process**

function that call itself VS
